<!DOCTYPE html><script type="module">
import App, {THREE} 			from "./fungi.3js/App.js";
import {Vec3,Quat,Transform }	from "./fungi/maths/Maths.js";
import GltfUtil, {Gltf} 		from "./fungi.3js/lib/GltfUtil.js";

import XhrQueue 		from "./fungi/lib/XhrQueue.js";
import Animation		from "./fungi/lib/Animation.js";

import PoseAnimator		from "./fungi.armature/PoseAnimator.js";
import IKRig 			from "./fungi.armature/IKRig.js";
import IKTarget 		from "./fungi.armature/IKTarget.js";
import { IKPose } from "./IKPose.js"
import { IKCompute } from "./IKCompute.js"

//#####################################################
App.builder( true )
	.init_mod( "./ecs/Armature.js", "./ecs/BoneSpring.js" ) //
	.set_camera( 40, 10, 3.5, 0, 0.75, 0 )
	.add( init )
	.render_loop( on_draw )
	//.render_on_mouse()
	.build();

//#####################################################
let gSrc, gModelA, gModelB, gModelC, gModelCX, gAnimate, gIKPose;
let paused = false, poseAnimator, poseAnimation;

document.body.addEventListener('keydown', (e) => {
  // console.log('key', e.key)
  // console.log('poseAnimator', poseAnimator)
  if (e.code === "Space") {
    paused = !paused

    const times = poseAnimator._frame_times( poseAnimation )
    console.log('times', times)
  }
})

function on_draw( dt, ss ){
	gAnimate( dt * 0.9 ); // * 0.1
}

async function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Download Resources
	let dl = await XhrQueue.url( "../shared" )
		.grp( "src", "anim/Walking.gltf", "json", "anim/Walking.bin", "bin", "anim/xrengine/Walking.glb.animation.run-forward.json", "animdata" )
		.grp( "src2", "anim/Walking.gltf", "json", "anim/Walking.bin", "bin" )
		.grp( "srcx", "anim/xrengine/Walking.glb.json", "json" )
        //.grp( "src", "anim/Catwalk.gltf", "json", "anim/Catwalk.bin", "bin" )
        //.grp( "src", "anim/Running.gltf", "json", "anim/Running.bin", "bin" )
        //.grp( "src", "anim/Standing.gltf", "json", "anim/Standing.bin", "bin" )
        //.grp( "src", "anim/Ready.gltf", "json", "anim/Ready.bin", "bin" )
		// .grp( "ma", "models/vegeta.gltf", "json", "models/vegeta.bin", "bin" )
		.grp( "mb", "models/robo_trex.gltf", "json", "models/robo_trex.bin", "bin" )
		.then();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Load Resources
	if( dl.src ) gAnimate = load_src( dl.src.json, dl.src.bin, dl.src.animdata, dl.srcx.json );
	if( dl.ma ) load_mesh_a( dl.ma.json, dl.ma.bin );
	if( dl.mb ) load_mesh_b( dl.mb.json, dl.mb.bin );
	if( dl.src2 ) load_mesh_c( dl.src2.json, dl.src2.bin );
	if( dl.srcx ) load_mesh_cx( dl.srcx.json, null );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Misc
	gIKPose = new IKPose();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gAnimate( 0.6225028089213559 );
  paused = true;

	return true;
}

//#####################################################
/**
 *
 * @param bones
 * @param {{ tracks: { name:string, type:string, times:number[], values:number[] }[]}} data
 * @param {boolean} limit
 * @return {{times: *, frame_cnt: *, time, tracks: *}}
 */
function adopt_three_animation_data(bones, data, limit = true) {
  let frame_max = 0, time_max = 0, time_ary = [], ch_ary = []

  for (const track of data.tracks) {
    const [ boneName, propertyName ] = track.name.split('.')
    const n_name = boneName.toLowerCase();

    /**
     * @var 'rot'|'pos'|'scl'
     */
    let prop;
    switch (propertyName) {
      case 'position': prop = 'pos'; break;
      case 'quaternion': prop = 'rot'; break;
      case 'scale': prop = 'scl'; break;
    }
    if( limit &&
      !( prop === "rot" ||
        ( n_name.indexOf("hip") !== -1 && prop === "pos" )
      )
    ) continue;

    //console.log('json.skins[ 0 ].joints', json.skins[ 0 ].joints)
    // json.skins[ 0 ].joints.findIndex(v => new RegExp(boneName + '$')
    const jointNameRgx = new RegExp(boneName + '$')
    const joint_idx = bones.findIndex(v => v.name.match(jointNameRgx))


    // switch Y with Z in track.values
    for (let i=0; i<track.values; i = i + (prop === 'rot'? 4 : 3)) {
      // const y = track.values[i + 1]
      // const z = track.values[i + 2]
      //
      // track.values[i + 1] = z
      // track.values[i + 2] = y
    }

    ch_ary.push({
      type		: prop,
      time_idx 	: 0, // we have all times equal
      joint_idx	: joint_idx,
      interp 		: "LINEAR",
      data		: track.values,
    });
  }

  // we have all times equal
  time_ary = [
    data.tracks[0].times
  ]

  frame_max	= data.tracks[0].times.length
  time_max = data.tracks[0].times.reduce((previousValue, currentValue) => Math.max(previousValue, currentValue), -1)

  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  let rtn = { time:time_max, frame_cnt: frame_max, times: time_ary, tracks:ch_ary };

  console.log('rtn2', rtn)
  return rtn;
}


function load_src( json, bin, animdata, json2 ){
  console.log('animdata', animdata)
	let e		= GltfUtil.get_bone_view( "src", json2, null );

	let anim0	= new Animation( Gltf.get_animation( json, bin ), true );
  console.log('ANIM0', anim0)
	let anim2	= new Animation( adopt_three_animation_data( e.Armature.bones, animdata ), true );
	console.log('ANIM2', anim2)

  const anim = anim2

	let pm		= new PoseAnimator();
  poseAnimator = pm
  poseAnimation = anim

	let rig 	= e.add_com( "IKRig" )
		.init( null, true, IKRig.ARM_MIXAMO )
		.recompute_from_tpose(); // Mesh requires a few bits to be recomputed because of Mixamo Scaling

	pm.root_idx	= 0;	// Get Rid of Motion from The Hip
	pm.root_z	= 1;	// Mixamo stuff is 90 degress off, so forward is Y :(

	gSrc  = e;

	return ( dt )=>{
    if (paused) {
      return
    }

		pm.tick( dt ).update( anim, rig.pose );
		rig.apply_pose();
    console.log('rig', rig)

		//-----------------------------
		IKCompute.run( gSrc, gIKPose );
		IKVisualize.run( gSrc, gIKPose );

		if( gModelA ){
			gIKPose.apply_rig( gModelA.IKRig );
			gModelA.IKRig.apply_pose();
		}

		if( gModelB ){
			gIKPose.apply_rig( gModelB.IKRig );
			gModelB.IKRig.apply_pose();
		}

		if( gModelC ){
			gIKPose.apply_rig( gModelC.IKRig );
			gModelC.IKRig.apply_pose();
		}

    if( gModelCX ){
      gIKPose.apply_rig( gModelCX.IKRig );
      gModelCX.IKRig.apply_pose();
    }


		/**/
	}
	return null;
}

function load_mesh_a( json, bin ){
	let e 		= GltfUtil.get_debug_view( "target_a", json, bin, new THREE.MeshPhongMaterial( { color: 0xff7f7f, shininess:1 } ) );
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	let rig 	= e.add_com( "IKRig" ).init( tpose, false );

	tpose.apply();

	rig.points.head.idx = rig.points.neck.idx; // Lil hack cause Head Isn't Skinned Well.
	e.Obj.set_pos( 1.0, 0, 0 );

	gModelA = e;
}

function load_mesh_c( json, bin ){
  let e		= GltfUtil.get_bone_view( "src", json, bin );
  let rig 	= e.add_com( "IKRig" )
     .init( null, true, IKRig.ARM_MIXAMO )
    .recompute_from_tpose(); // Mesh requires a few bits to be recomputed because of Mixamo Scaling

  rig.points.head.idx = rig.points.neck.idx; // Lil hack cause Head Isn't Skinned Well.
  console.log('e.Obj', e.Obj)
  e.Obj.set_pos( -1, 1, 0 );

  gModelC = e;
}

function load_mesh_cx( json ){
  let e		= GltfUtil.get_bone_view( "src", json, null );
  let rig 	= e.add_com( "IKRig" )
    .init( null, true, IKRig.ARM_MIXAMO )
    .recompute_from_tpose(); // Mesh requires a few bits to be recomputed because of Mixamo Scaling

  rig.points.head.idx = rig.points.neck.idx; // Lil hack cause Head Isn't Skinned Well.
  console.log('e.Obj', e.Obj)
  e.Obj.set_pos( 1, 0, 0 );

  gModelCX = e;
}

function load_mesh_b( json, bin ){
  console.log('load_mesh_b', 'robo_trex')

	let e 		= GltfUtil.get_debug_view( "target_b", json, bin, new THREE.MeshPhongMaterial( { color: 0xff7f7f, shininess:1, flatShading:true } ) );
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
  /**
   * @var {IKRig}
   */
	let rig 	= e
		.add_com( "IKRig" )

  rig
		.init( tpose, false, 0 )

		.add_point( "hip", "hip" )
		.add_point( "head", "face_joint" )
		.add_point( "foot_l", "LeftFoot" )
		.add_point( "foot_r", "RightFoot" )

		.add_point( "wing_l", "left_wing" )
		.add_point( "wing_r", "right_wing" )

		.add_chain( "leg_r", [ "RightUpLeg", "RightKnee", "RightShin" ], "RightFoot", "three_bone" ) //"z",
		.add_chain( "leg_l", [ "LeftUpLeg", "LeftKnee", "LeftShin" ], "LeftFoot", "three_bone" ) // "z",
		.add_chain( "spine", [ "Spine", "Spine1" ] )
		.add_chain( "tail", ["tail_1","tail_2","tail_3","tail_4","tail_5","tail_6","tail_7"] )
		.set_leg_lmt( null, -0.1 )
	;

	rig.chains.leg_l.set_alt( Vec3.DOWN, Vec3.FORWARD, rig.tpose );
	rig.chains.leg_r.set_alt( Vec3.DOWN, Vec3.FORWARD, rig.tpose );
	/**/

	tpose.apply();

	// Add some Spring Movement to specific bones
	e.add_com( "BoneSpring" )
		.add( rig.get_chain_indices( "tail" ), 2.9, 0.9, -0.1 )
		.add( rig.points.wing_l.idx, 3.0, 0.9 )
		.add( rig.points.wing_r.idx, 3.0, 0.9 );

	e.Obj.set_pos( -1.0, 0, 0 );
	gModelB = e;
}

//#####################################################

// #region IK CLASSES

// How to visualize the IK Pose Informaation to get an Idea of what we're looking at.
class IKVisualize{
	static run( e, ik ){
		let rig = e.IKRig;
        this.hip( rig, ik );

		this.limb( rig.pose, rig.chains.leg_l, ik.leg_l );
		this.limb( rig.pose, rig.chains.leg_r, ik.leg_r );
		this.limb( rig.pose, rig.chains.arm_l, ik.arm_l );
        this.limb( rig.pose, rig.chains.arm_r, ik.arm_r );

		this.look_twist( rig, rig.points.foot_l, ik.foot_l, Vec3.FORWARD, Vec3.UP );
		this.look_twist( rig, rig.points.foot_r, ik.foot_r, Vec3.FORWARD, Vec3.UP );

        this.spine( rig, rig.chains.spine, ik.spine );

        this.look_twist( rig, rig.points.head, ik.head, Vec3.FORWARD, Vec3.UP );
	}

	static hip( rig, ik ){
		let ws = rig.pose.bones[ rig.points.hip.idx ].world;
		App.Debug
			.pnt( ws.pos, CLR.orange, 6, 6 )
			.ln( ws.pos, Vec3.scale( ik.hip.dir, 0.20 ).add( ws.pos ), CLR.cyan, null, true );
	}
	//static pnt( p, hex=0xff0000, shape=null, size=null ){ this.p.add( p, hex, shape, size ); return this; }

	static limb( pose, chain, ik ){
		let len		= chain.len * ik.len_scale,
			posA	= pose.bones[ chain.first() ].world.pos,		// Starting Point in Limb
			posB	= Vec3.scale( ik.dir, len ).add( posA ),		// Direction + Length to End Effector
			posC	= Vec3.scale( ik.joint_dir, 0.2 ).add( posA );	// Direction of Joint

		App.Debug
			.pnt( posA, CLR.yellow, 6, 4 )
			.pnt( posB, CLR.orange, 6, 4 )
			.ln( posA, posB, CLR.yellow, CLR.orange, true )
			.ln( posA, posC, CLR.yellow, null, true );
    }

    // Was Originally called Foot.
	static look_twist( rig, b_info, ik, look_dir, twist_dir ){
		let pos = rig.pose.bones[ b_info.idx ].world.pos;
		App.Debug
            .pnt( pos, CLR.cyan, 1, 2.5 )												   		// Foot Position
			.ln( pos, Vec3.scale( ik.look_dir, 0.2 ).add( pos ), CLR.cyan, null, true )		// IK.DIR
			.ln( pos, Vec3.scale( ik.twist_dir, 0.2 ).add( pos ), CLR.cyan, null, true );	// RESULT OF IK.TWIST
	}

	static spine( rig, chain, ik_ary ){
		let ws, ik, idx = [ chain.first(), chain.last() ];

		for( let i=0; i < 2; i++ ){
			ws = rig.pose.bones[ idx[i] ].world;
			ik = ik_ary[ i ];

			App.Debug
				.pnt( ws.pos, CLR.orange, 1, 2 )
				.ln( ws.pos, Vec3.scale( ik.look_dir, 0.2 ).add(ws.pos), CLR.yellow, null )
				.ln( ws.pos, Vec3.scale( ik.twist_dir, 0.2 ).add(ws.pos), CLR.orange, null );
		}
	}
}

let CLR = {
	"black"		: 0x000000,
	"white"		: 0xffffff,
	"red"		: 0xff0000,
	"green"		: 0x00ff00,
	"blue"		: 0x0000ff,
	"fuchsia"	: 0xff00ff,
	"cyan"		: 0x00ffff,
	"yellow"	: 0xffff00,
	"orange"	: 0xff8000,
};
// #endregion ///////////////////////////////////////////

</script><page-layout></page-layout>
